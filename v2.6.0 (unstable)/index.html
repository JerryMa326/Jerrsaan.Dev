<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Color Analysis Tool - Complete Enhanced Version</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            background-color: #333;
            overflow: hidden;
            font-family: "Segoe UI", Arial, sans-serif;
        }

        /* Container with zoom support */
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
            overflow: hidden;
        }

        /* Canvas with zoom functionality */
        #canvasContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-origin: center center;
            transition: transform 0.1s ease;
        }

        #videoCanvas {
            display: block;
            margin: auto;
            border: 2px solid #444;
            border-radius: 4px;
        }

        /* Grid view */
        #gridView {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            overflow: auto;
            padding: 15px;
            box-sizing: border-box;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }

        .grid-item {
            position: relative;
            background: #222;
            border: 2px solid #555;
            border-radius: 8px;
            overflow: hidden;
            min-height: 300px;
        }

        .grid-item-header {
            background: rgba(74, 144, 226, 0.15);
            padding: 4px 8px;
            font-size: 11px;
            font-weight: 400;
            color: rgba(74, 144, 226, 0.8);
            border-bottom: 1px solid rgba(85, 85, 85, 0.5);
        }

        .grid-item canvas {
            width: 100%;
            height: 220px;
            object-fit: contain;
            background: #111;
            cursor: crosshair;
        }

        .grid-item-controls {
            padding: 8px;
            background: rgba(40, 40, 40, 0.9);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        .grid-item-label-input {
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(85, 85, 85, 0.5);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            flex: 1;
            height: 20px;
        }

        /* DRAGGABLE UI ELEMENTS */
        .draggable-ui {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: move;
            user-select: none;
            z-index: 1000;
            max-width: 300px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .draggable-ui:hover {
            background: rgba(0, 0, 0, 0.95);
        }

        .draggable-ui .drag-handle {
            padding: 4px 8px;
            background: rgba(74, 144, 226, 0.3);
            border-radius: 6px 6px 0 0;
            font-size: 10px;
            color: #4a90e2;
            cursor: move;
        }

        /* UNIFIED BUTTON STYLING */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font: 13px/1.2 "Segoe UI", Arial, sans-serif;
            padding: 6px 12px;
            border: none;
            border-radius: 5px;
            background: linear-gradient(145deg, #4a90e2, #357abd);
            color: #fff;
            cursor: pointer;
            transition: all .2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, .25);
            margin: 2px;
        }

        .btn:hover {
            background: linear-gradient(145deg, #357abd, #2a5f8f);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, .35);
        }

        .btn--success {
            background: linear-gradient(145deg, #28a745, #1e7e34);
        }

        .btn--danger {
            background: linear-gradient(145deg, #dc3545, #c82333);
        }

        .btn--small {
            padding: 3px 6px;
            font-size: 11px;
        }

        /* UI ELEMENTS */
        .color-display {
            padding: 8px 12px;
            font-size: 13px;
            color: #eee;
            font-family: 'Courier New', monospace;
            max-width: 200px;
        }

        .color-mode-selector {
            padding: 6px 10px;
        }

        .quiz-option {
            display: inline-block;
            margin: 0 6px;
            cursor: pointer;
            vertical-align: middle;
            color: #eee;
            font-size: 12px;
        }

        .quiz-circle {
            width: 12px;
            height: 12px;
            border: 2px solid #eee;
            border-radius: 50%;
            display: inline-block;
            vertical-align: middle;
            margin-right: 3px;
            transition: all 0.2s;
        }

        .quiz-circle.selected {
            background-color: #4a90e2;
            border-color: #4a90e2;
        }

        #houghControls {
            padding: 10px;
            color: #eee;
            font-size: 13px;
            max-width: 180px;
            max-height: 350px;
            overflow-y: auto;
        }

        #houghControls .control {
            margin-bottom: 8px;
        }

        #houghControls .control:last-child {
            margin-bottom: 0;
        }

        #houghControls .control label {
            display: block;
            margin-bottom: 3px;
            font-weight: 500;
            font-size: 12px;
        }

        #houghControls .control input[type="number"] {
            width: 45px;
            margin-left: 6px;
            font-size: 12px;
            padding: 2px 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #555;
            color: #eee;
            border-radius: 3px;
        }

        #houghControls .control input[type="range"] {
            width: 100%;
            margin-top: 4px;
        }

        #houghControls .control select {
            width: 100%;
            padding: 2px 4px;
            background: rgba(0, 0, 0, 0.3);
            color: #eee;
            border: 1px solid #555;
            border-radius: 3px;
            font-size: 11px;
        }

        #circleInfo {
            padding: 8px 10px;
            color: #eee;
            max-width: 220px;
            font-size: 12px;
        }

        #circleInfo h3 {
            margin: 0 0 6px 0;
            font-size: 13px;
            color: #4a90e2;
        }

        #circleInfo ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #circleInfo li {
            margin-bottom: 4px;
            padding: 2px 4px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.05);
            font-size: 11px;
        }

        #removeCircleBox {
            padding: 8px 10px;
            color: #eee;
            font-size: 12px;
        }

        #removeCircleBox select {
            padding: 2px 4px;
            background: rgba(0, 0, 0, 0.3);
            color: #eee;
            border: 1px solid #555;
            border-radius: 3px;
            font-size: 11px;
            margin: 0 4px;
        }

        .zoom-controls {
            padding: 6px 10px;
        }

        .zoom-btn {
            background: rgba(74, 144, 226, 0.8);
            border: none;
            color: #fff;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            margin: 0 2px;
        }

        .zoom-level {
            color: #eee;
            font-size: 12px;
            margin: 0 8px;
        }

        .grid-auto-detect {
            padding: 8px 12px;
            max-width: 250px;
        }

        /* Chart tooltip styling */
        .chart-tooltip {
            font-family: 'Segoe UI', Arial, sans-serif;
            line-height: 1.4;
            white-space: nowrap;
        }

        /* Regression studio styles */
        #regressionTab .studio-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: rgba(40, 40, 40, 0.95);
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
        }

        #regressionTab .studio-container * {
            color: #eee;
            font-family: "Segoe UI", Arial, sans-serif;
        }

        #regressionTab h2 {
            text-align: center;
            margin: 0 0 20px 0;
            font-size: 1.8rem;
            font-weight: 300;
            color: #4a90e2;
        }

        .precision-control {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding: 12px;
            background: rgba(60, 60, 60, 0.7);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .precision-control label {
            color: #eee;
            font-weight: 500;
        }

        .precision-control select {
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.3);
            color: #eee;
            border: 1px solid #555;
            border-radius: 6px;
            font-size: 14px;
        }

        /* Axis swap control */
        .axis-control {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding: 12px;
            background: rgba(60, 60, 60, 0.7);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chart-controls {
            text-align: center;
            margin: 15px 0;
            padding: 12px;
            background: rgba(60, 60, 60, 0.5);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chart-controls label {
            color: #eee;
            font-size: 14px;
            margin: 0 15px;
        }

        .chart-controls input[type="checkbox"] {
            margin-right: 8px;
        }

        .table-wrapper {
            overflow-x: auto;
            overflow-y: auto;
            max-height: 400px;
            margin-bottom: 20px;
            border: 1px solid #555;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
        }

        #regressionTable {
            width: 100%;
            table-layout: fixed;
            border-collapse: collapse;
        }

        #regressionTable th:nth-child(1) { width: 12%; }
        #regressionTable th:nth-child(2) { width: 25%; }
        #regressionTable th:nth-child(3) { width: 25%; }
        #regressionTable th:nth-child(4) { width: 18%; }
        #regressionTable th:nth-child(5) { width: 12%; }
        #regressionTable th:nth-child(6) { width: 8%; }

        #regressionTable th,
        #regressionTable td {
            border: 1px solid #555;
            padding: 8px;
            text-align: center;
            word-wrap: break-word;
        }

        #regressionTable th {
            background: linear-gradient(145deg, #4a90e2, #357abd);
            font-weight: 500;
            color: #fff;
        }

        #regressionTable td {
            background: rgba(255, 255, 255, 0.02);
        }

        #regressionTable input[type="number"] {
            width: 90%;
            padding: 6px;
            border: 1px solid #777;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            font-size: 14px;
            text-align: center;
        }

        #multipleChartsContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
            justify-content: center;
            max-height: 80vh;
            overflow-y: auto;
        }

        .regression-chart {
            border: 2px solid #555;
            border-radius: 8px;
            background: #111;
        }

        .chart-title {
            text-align: center;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #4a90e2;
        }

        .species-icon {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            border: 1px solid #555;
            display: block;
            margin: 0 auto;
            object-fit: contain;
            background: #222;
        }

        .controls {
            text-align: center;
            margin: 20px 0;
        }

        .predict-section {
            text-align: center;
            margin: 15px 0;
            padding: 15px;
            background: rgba(60, 60, 60, 0.5);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        select {
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.3);
            color: #eee;
            border: 1px solid #555;
            border-radius: 6px;
            font-size: 14px;
            margin: 0 4px;
        }

        .tab-btn {
            flex: 1;
            padding: 12px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
        }

        .tab-btn.selected {
            color: #4a90e2 !important;
            border-bottom-color: #4a90e2;
        }

        #fileInput, #importModelInput {
            display: none;
        }

        #noCirclesMsg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff6b6b;
            font-size: 20px;
            font-weight: 500;
            display: none;
            pointer-events: none;
            animation: floatIn 0.5s ease-out;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            border-radius: 8px;
            border: 2px solid #ff6b6b;
            z-index: 10000;
        }

        @keyframes floatIn {
            from {
                opacity: 0;
                transform: translate(-50%, calc(-50% + 50px));
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
    </style>
</head>

<body>
    <!-- Tab navigation -->
    <div id="tabNav" style="position:absolute; top:0; left:0; width:100%; background:rgba(34,34,34,0.95); z-index:1000; display:flex; backdrop-filter:blur(10px);">
        <button id="tabDetectBtn" class="tab-btn selected">Detection</button>
        <button id="tabRegressionBtn" class="tab-btn">Regression Studio</button>
    </div>

    <!-- Detection Tab -->
    <div id="detectTab" style="position:absolute; top:45px; left:0; right:0; bottom:0;">
        <div id="container">
            <div id="canvasContainer">
                <canvas id="videoCanvas"></canvas>
            </div>
            
            <div id="gridView">
                <div class="grid-container" id="gridContainer"></div>
                
                <div class="draggable-ui grid-auto-detect" id="gridAutoDetectUI">
                    <div class="drag-handle">Grid Controls</div>
                    <button id="autoDetectAllBtn" class="btn btn--small">Auto-Detect All Images</button>
                    <button id="resetAllGridBtn" class="btn btn--danger btn--small">Reset All Shapes</button>
                </div>
            </div>

            <!-- Draggable UI Elements -->
            <div class="draggable-ui zoom-controls" id="zoomControlsUI">
                <div class="drag-handle">Zoom</div>
                <button class="zoom-btn" id="zoomOutBtn">−</button>
                <span class="zoom-level" id="zoomLevel">100%</span>
                <button class="zoom-btn" id="zoomInBtn">+</button>
                <button class="zoom-btn" id="zoomResetBtn">Reset</button>
            </div>

            <button id="gridToggleBtn" class="btn" style="position: fixed; bottom: 90px; left: 10px;">Grid View</button>

            <div class="draggable-ui color-display" id="colorDisplayUI">
                <div class="drag-handle">Color Info</div>
                <div id="colorDisplay">
                    <div style="margin-bottom: 4px;">RGB: 0, 0, 0</div>
                    <div style="font-size: 10px; color: rgba(255,255,255,0.7);">
                        [1]Rect [2]Circle [C]Capture [O]Open [R]Reset [A]Auto
                    </div>
                </div>
            </div>

            <div class="draggable-ui color-mode-selector" id="colorModeUI">
                <div class="drag-handle">Color Mode</div>
                <span class="quiz-option" id="quizRGB">
                    <span class="quiz-circle" id="circleRGB"></span>RGB
                </span>
                <span class="quiz-option" id="quizCMYK">
                    <span class="quiz-circle" id="circleCMYK"></span>CMYK
                </span>
            </div>

            <div class="draggable-ui" id="houghControlsUI">
                <div class="drag-handle">Circle Detection</div>
                <div id="houghControls">
                    <!-- Circle sorting control -->
                    <div class="control">
                        <label>Label Sort Order:</label>
                        <select id="circleSortOrder">
                            <option value="none">Detection Order</option>
                            <option value="topDown">Top to Bottom</option>
                            <option value="leftRight">Left to Right</option>
                        </select>
                    </div>
                    
                    <div class="control">
                        <label>Param1
                            <input type="number" id="param1Val" min="10" max="300" value="100" step="1">
                        </label>
                        <input type="range" id="param1Range" min="10" max="300" value="100" step="1">
                    </div>
                    <div class="control">
                        <label>Param2
                            <input type="number" id="param2Val" min="10" max="200" value="50" step="1">
                        </label>
                        <input type="range" id="param2Range" min="10" max="200" value="50" step="1">
                    </div>
                    <div class="control">
                        <label>Min Radius
                            <input type="number" id="minRadiusVal" min="1" max="500" value="20" step="1">
                        </label>
                        <input type="range" id="minRadiusRange" min="1" max="500" value="20" step="1">
                    </div>
                    <div class="control">
                        <label>Max Radius
                            <input type="number" id="maxRadiusVal" min="10" max="500" value="150" step="1">
                        </label>
                        <input type="range" id="maxRadiusRange" min="10" max="500" value="150" step="1">
                    </div>
                    <div class="control">
                        <label>Area (%)
                            <input type="number" id="restrictedAreaVal" min="1" max="100" value="80" step="1">
                        </label>
                        <input type="range" id="restrictedAreaRange" min="1" max="100" value="80" step="1">
                    </div>
                </div>
            </div>

            <div id="noCirclesMsg">No circles detected</div>

            <div class="draggable-ui" id="circleInfoUI">
                <div class="drag-handle">Detected Shapes</div>
                <div id="circleInfo">
                    <h3>Detected Shapes</h3>
                    <ul id="circleList"></ul>
                </div>
            </div>

            <div class="draggable-ui" id="removeCircleUI">
                <div class="drag-handle">Remove Shape</div>
                <div id="removeCircleBox">
                    <label for="circleSelect">Remove:</label>
                    <select id="circleSelect"></select>
                    <button class="btn btn--danger btn--small" id="removeCircleButton">×</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Regression Studio tab -->
    <div id="regressionTab" style="display:none; position:absolute; top:45px; left:0; right:0; bottom:0; background:#222; overflow:auto; padding:15px;">
        <div class="studio-container">
            <h2>Regression Studio</h2>

            <div class="precision-control">
                <label for="precisionSelector">RGB/CMYK Precision:</label>
                <select id="precisionSelector">
                    <option value="0">0 decimals</option>
                    <option value="1">1 decimal</option>
                    <option value="2">2 decimals</option>
                    <option value="3" selected>3 decimals</option>
                    <option value="4">4 decimals</option>
                    <option value="5">5 decimals</option>
                </select>
                <span style="color: #aaa; font-size: 12px; margin-left: 10px;">
                    Affects both RGB and CMYK value display
                </span>
            </div>

            <!-- Axis swap control -->
            <div class="axis-control">
                <label for="axisSwapSelector">Regression Axes:</label>
                <select id="axisSwapSelector">
                    <option value="normal">X: Color → Y: Concentration</option>
                    <option value="swapped">X: Concentration → Y: Color</option>
                </select>
                <span style="color: #aaa; font-size: 12px; margin-left: 10px;">
                    Swap X and Y axes for regression analysis
                </span>
            </div>

            <!-- Chart display controls -->
            <div class="chart-controls">
                <label>
                    <input type="checkbox" id="showRegressionToggle" checked>
                    Show Regression Line & R²
                </label>
                <label>
                    <input type="checkbox" id="showScalesToggle" checked>
                    Show Chart Scales
                </label>
            </div>

            <div style="background: rgba(60, 60, 60, 0.9); padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid rgba(255, 255, 255, 0.1);">
                <h3>Image Management</h3>
                <div id="imageThumbnails"></div>
                <button id="addImagesBtn" class="btn">Add Images</button>
            </div>

            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
                <div>
                    <button id="toggleColorMode" class="btn">
                        Color Mode: <span id="currentColorMode">RGB</span>
                    </button>
                </div>
                <div>
                    <label for="chartSelector">Chart Display:</label>
                    <select id="chartSelector">
                        <option value="all">All Charts</option>
                        <option value="red">Red</option>
                        <option value="green">Green</option>
                        <option value="blue">Blue</option>
                        <option value="cyan">Cyan</option>
                        <option value="magenta">Magenta</option>
                        <option value="yellow">Yellow</option>
                        <option value="total">Total Magnitude</option>
                    </select>
                </div>
            </div>

            <div class="table-wrapper">
                <table id="regressionTable">
                    <thead>
                        <tr>
                            <th>Label</th>
                            <th>RGB Values</th>
                            <th>CMYK Values</th>
                            <th>Known Molarity</th>
                            <th>Species</th>
                            <th>Remove</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>

            <div style="text-align: center; margin: 20px 0;">
                <button id="downloadCSV" class="btn btn--success">
                    Download CSV
                </button>
            </div>

            <div class="predict-section">
                <h4>Prediction</h4>
                <select id="predictShapeSelect"></select>
                <button id="predictBtn" class="btn">Predict</button>
                <div id="predictOutput"></div>
            </div>

            <div class="controls">
                <button id="runRegressionBtn" class="btn">Run Regression</button>
                <button id="exportModelBtn" class="btn">Export Model</button>
                <button id="importModelBtn" class="btn">Import Model</button>
            </div>

            <div id="regressionOutput" style="margin-top:15px; font-family:monospace; font-size:14px; text-align:center;"></div>

            <div id="multipleChartsContainer">
                <div>
                    <div class="chart-title">Red Component</div>
                    <canvas id="redChart" class="regression-chart" width="280" height="180"></canvas>
                </div>
                <div>
                    <div class="chart-title">Green Component</div>
                    <canvas id="greenChart" class="regression-chart" width="280" height="180"></canvas>
                </div>
                <div>
                    <div class="chart-title">Blue Component</div>
                    <canvas id="blueChart" class="regression-chart" width="280" height="180"></canvas>
                </div>
                <div>
                    <div class="chart-title">Cyan Component</div>
                    <canvas id="cyanChart" class="regression-chart" width="280" height="180"></canvas>
                </div>
                <div>
                    <div class="chart-title">Magenta Component</div>
                    <canvas id="magentaChart" class="regression-chart" width="280" height="180"></canvas>
                </div>
                <div>
                    <div class="chart-title">Yellow Component</div>
                    <canvas id="yellowChart" class="regression-chart" width="280" height="180"></canvas>
                </div>
                <div>
                    <div class="chart-title">Total Magnitude</div>
                    <canvas id="totalChart" class="regression-chart" width="280" height="180"></canvas>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept="image/*" multiple>
    <input type="file" id="importModelInput" accept=".json">

    <script>
        // Global state variables
        let video = document.createElement('video');
        video.setAttribute('autoplay', true);
        video.setAttribute('playsinline', true);
        let canvas = document.getElementById('videoCanvas');
        let ctx = canvas.getContext('2d');
        let fileInput = document.getElementById('fileInput');
        let committedData = JSON.parse(localStorage.getItem('committedData') || '[]');
        let imageMode = false;
        let loadedImages = [];
        let currentImageIndex = 0;
        let streaming = false;
        let regressionModels = {};
        let imageLabels = JSON.parse(localStorage.getItem('imageLabels') || '{}');

        // Enhanced variables
        let isGridView = false;
        let decimalPrecision = 3;
        let axesSwapped = false;

        // Drawing mode
        let selectionMode = "rectangle";
        let currentDrag = null;
        let currentShape = null;

        // Shape management
        let shapesByImage = {};
        let shapes = [];
        let shapeIdCounter = 0;
        let availableLabels = [];

        // Zoom variables
        let zoomLevel = 1.0;
        let minZoom = 0.5;
        let maxZoom = 3.0;
        let zoomStep = 0.1;
        let baseCanvasSize = { width: 640, height: 480 };

        // Track current mouse position
        let currentMousePos = { x: 0, y: 0 };

        // Color mode
        let colorMode = "RGB";
        let regressionStudioColorMode = "RGB";

        // Interactive tooltip system
        let currentTooltip = null;

        // DRAGGABLE UI FUNCTIONALITY
        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            const header = element.querySelector('.drag-handle') || element;
            
            header.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                
                let newTop = element.offsetTop - pos2;
                let newLeft = element.offsetLeft - pos1;
                
                newTop = Math.max(45, Math.min(window.innerHeight - element.offsetHeight, newTop));
                newLeft = Math.max(0, Math.min(window.innerWidth - element.offsetWidth, newLeft));
                
                element.style.top = newTop + "px";
                element.style.left = newLeft + "px";
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        // Initialize draggable UI elements
        function initializeDraggableUI() {
            const positions = {
                colorDisplayUI: { top: '60px', left: '10px' },
                colorModeUI: { top: '150px', left: '10px' },
                houghControlsUI: { top: '60px', right: '10px' },
                circleInfoUI: { top: '200px', left: '10px' },
                removeCircleUI: { top: '60px', right: '200px' },
                zoomControlsUI: { top: '60px', left: '50%', transform: 'translateX(-50%)' },
                gridAutoDetectUI: { bottom: '10px', right: '10px' }
            };

            Object.keys(positions).forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    const pos = positions[id];
                    Object.keys(pos).forEach(prop => {
                        element.style[prop] = pos[prop];
                    });
                    makeDraggable(element);
                }
            });
        }

        // Format color values with proper precision
        function formatColorValue(num) {
            const precision = parseInt(document.getElementById('precisionSelector').value, 10);
            return Number(num.toFixed(precision));
        }

        // Get current image key
        function getCurrentImageKey() {
            return imageMode ? `image_${currentImageIndex}` : 'camera';
        }

        // Update shapes when switching images
        function updateCurrentShapes() {
            const imageKey = getCurrentImageKey();
            if (!shapesByImage[imageKey]) {
                shapesByImage[imageKey] = [];
            }
            shapes = shapesByImage[imageKey];
        }

        // Enhanced label management
        function getNextAvailableLabel() {
            const english = "abcdefghijklmnopqrstuvwxyz";
            const greek = "αβγδεζηθικλμνξοπρστυφχψω";
            const arabic = "ابتثجحخدذرزسشصضطظعغفقكلمنهوي";
            
            if (availableLabels.length > 0) {
                return availableLabels.shift();
            }
            
            const allChars = english + greek + arabic;
            if (shapeIdCounter < allChars.length) {
                return allChars[shapeIdCounter++];
            } else {
                return "?" + shapeIdCounter++;
            }
        }

        function recycleLabel(label) {
            const english = "abcdefghijklmnopqrstuvwxyz";
            const greek = "αβγδεζηθικλμνξοπρστυφχψω";
            const arabic = "ابتثجحخدذرزسشصضطظعغفقكلمنهوي";
            const allChars = english + greek + arabic;
            
            const labelIndex = allChars.indexOf(label);
            if (labelIndex !== -1 && !availableLabels.includes(label)) {
                availableLabels.push(label);
                availableLabels.sort((a, b) => allChars.indexOf(a) - allChars.indexOf(b));
            }
        }

        function resetLabeling() {
            shapeIdCounter = 0;
            availableLabels = [];
        }

        // ZOOM FUNCTIONALITY - NORMALIZED RADIUS CALCULATIONS
        function updateZoom() {
            const container = document.getElementById('canvasContainer');
            container.style.transform = `scale(${zoomLevel})`;
            document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
        }

        function zoomIn() {
            if (zoomLevel < maxZoom) {
                zoomLevel = Math.min(maxZoom, zoomLevel + zoomStep);
                updateZoom();
            }
        }

        function zoomOut() {
            if (zoomLevel > minZoom) {
                zoomLevel = Math.max(minZoom, zoomLevel - zoomStep);
                updateZoom();
            }
        }

        function resetZoom() {
            zoomLevel = 1.0;
            updateZoom();
        }

        // NORMALIZED RADIUS CALCULATIONS
        function getNormalizedRadius(radius, currentCanvasSize) {
            const scaleX = baseCanvasSize.width / currentCanvasSize.width;
            const scaleY = baseCanvasSize.height / currentCanvasSize.height;
            const avgScale = (scaleX + scaleY) / 2;
            return radius * avgScale;
        }

        function getDenormalizedRadius(normalizedRadius, currentCanvasSize) {
            const scaleX = currentCanvasSize.width / baseCanvasSize.width;
            const scaleY = currentCanvasSize.height / baseCanvasSize.height;
            const avgScale = (scaleX + scaleY) / 2;
            return normalizedRadius * avgScale;
        }

        // Grid view toggle
        function toggleGridView() {
            isGridView = !isGridView;
            const gridView = document.getElementById('gridView');
            const canvasContainer = document.getElementById('canvasContainer');
            
            if (isGridView) {
                gridView.style.display = 'block';
                canvasContainer.style.display = 'none';
                updateGridView();
            } else {
                gridView.style.display = 'none';
                canvasContainer.style.display = 'block';
                if (streaming) {
                    resizeCanvasToAspect();
                }
            }
        }

        // ENHANCED GRID VIEW - Shows all shapes, no relabeling
        function updateGridView() {
            const container = document.getElementById('gridContainer');
            container.innerHTML = '';

            loadedImages.forEach((img, index) => {
                const gridItem = document.createElement('div');
                gridItem.className = 'grid-item';
                
                const header = document.createElement('div');
                header.className = 'grid-item-header';
                header.textContent = imageLabels[`image_${index}`] || `Image ${index + 1}`;
                
                const canvas = document.createElement('canvas');
                canvas.width = 320;
                canvas.height = 200;
                const ctx = canvas.getContext('2d');
                canvas.setAttribute('data-image-index', index);
                canvas.style.cursor = 'crosshair';
                
                drawImageWithAspect(ctx, img, canvas.width, canvas.height);
                
                const imageKey = `image_${index}`;
                if (shapesByImage[imageKey]) {
                    shapesByImage[imageKey].forEach(shape => {
                        drawShapeOnCanvas(ctx, shape, canvas.width, canvas.height, img);
                    });
                }
                
                setupGridCanvasInteraction(canvas, index);
                
                const controls = document.createElement('div');
                controls.className = 'grid-item-controls';
                
                const labelInput = document.createElement('input');
                labelInput.className = 'grid-item-label-input';
                labelInput.type = 'text';
                labelInput.placeholder = 'Label...';
                labelInput.value = imageLabels[`image_${index}`] || '';
                labelInput.addEventListener('input', function() {
                    imageLabels[`image_${index}`] = this.value;
                    localStorage.setItem('imageLabels', JSON.stringify(imageLabels));
                    header.textContent = this.value || `Image ${index + 1}`;
                });
                
                const autoDetectBtn = document.createElement('button');
                autoDetectBtn.className = 'btn btn--small';
                autoDetectBtn.textContent = 'Auto';
                autoDetectBtn.addEventListener('click', () => autoDetectOnImage(index));
                
                controls.appendChild(labelInput);
                controls.appendChild(autoDetectBtn);
                
                gridItem.appendChild(header);
                gridItem.appendChild(canvas);
                gridItem.appendChild(controls);
                
                container.appendChild(gridItem);
            });
        }

        // Auto-detect all images functionality
        function autoDetectAllImages() {
            if (typeof cv === 'undefined') {
                alert('OpenCV.js not loaded yet. Please wait.');
                return;
            }

            let processed = 0;
            const total = loadedImages.length;
            
            loadedImages.forEach((img, index) => {
                setTimeout(() => {
                    autoDetectOnImage(index);
                    processed++;
                    
                    if (processed === total) {
                        alert(`Auto-detection completed for ${total} images.`);
                        updateGridView();
                        updateShapeList();
                    }
                }, index * 100);
            });
        }

        // OPTIMIZED CIRCLE DETECTION with multi-stage preprocessing
        function autoDetectOnImage(imageIndex) {
            if (typeof cv === 'undefined') {
                alert('OpenCV.js not loaded yet. Please wait.');
                return;
            }

            let sourceCanvas;
            if (imageIndex >= 0 && imageIndex < loadedImages.length) {
                sourceCanvas = document.createElement('canvas');
                sourceCanvas.width = 640;
                sourceCanvas.height = 480;
                const sourceCtx = sourceCanvas.getContext('2d');
                drawImageWithAspect(sourceCtx, loadedImages[imageIndex], sourceCanvas.width, sourceCanvas.height);
            } else {
                sourceCanvas = getCurrentFrame();
            }

            sourceCanvas.style.display = "none";
            document.body.appendChild(sourceCanvas);
            let src = cv.imread(sourceCanvas);
            document.body.removeChild(sourceCanvas);

            // ENHANCED: Multi-stage preprocessing pipeline
            let gray = new cv.Mat();
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
            
            // Stage 1: Noise reduction with bilateral filter
            let bilateral = new cv.Mat();
            cv.bilateralFilter(gray, bilateral, 9, 75, 75);
            
            // Stage 2: Contrast enhancement
            let enhanced = new cv.Mat();
            cv.equalizeHist(bilateral, enhanced);
            
            // Stage 3: Adaptive Gaussian blur based on image size
            let blur = new cv.Mat();
            let ksize = Math.max(5, Math.floor(Math.min(src.rows, src.cols) / 100));
            if (ksize % 2 === 0) ksize += 1;
            cv.GaussianBlur(enhanced, blur, new cv.Size(ksize, ksize), 0);
            
            // Stage 4: Edge detection with Canny for better circle boundaries
            let edges = new cv.Mat();
            let param1 = parseInt(document.getElementById('param1Val').value);
            cv.Canny(blur, edges, param1/2, param1);
            
            let circles = new cv.Mat();
            let param2 = parseInt(document.getElementById('param2Val').value);
            let minRadius = parseInt(document.getElementById('minRadiusVal').value);
            let maxRadius = parseInt(document.getElementById('maxRadiusVal').value);
            
            // ENHANCED: Adaptive minimum distance calculation
            let imgDiag = Math.sqrt(src.rows * src.rows + src.cols * src.cols);
            let minDist = Math.max(minRadius * 1.2, imgDiag / 50);

            // ENHANCED: Multiple detection passes with different parameters
            let allCircles = [];
            
            // Pass 1: Conservative detection
            cv.HoughCircles(edges, circles, cv.HOUGH_GRADIENT, 1, minDist, param1, param2 * 1.2, minRadius, maxRadius);
            if (!circles.empty()) {
                for (let i = 0; i < circles.cols; i++) {
                    allCircles.push([circles.data32F[i * 3], circles.data32F[i * 3 + 1], circles.data32F[i * 3 + 2]]);
                }
            }
            
            // Pass 2: Relaxed detection for missed circles
            circles.delete();
            circles = new cv.Mat();
            cv.HoughCircles(blur, circles, cv.HOUGH_GRADIENT, 1.2, minDist * 0.8, param1 * 0.8, param2 * 0.8, minRadius, maxRadius);
            if (!circles.empty()) {
                for (let i = 0; i < circles.cols; i++) {
                    let newCircle = [circles.data32F[i * 3], circles.data32F[i * 3 + 1], circles.data32F[i * 3 + 2]];
                    // Check for duplicates
                    let isDuplicate = allCircles.some(existing => {
                        let dist = Math.sqrt(Math.pow(existing[0] - newCircle[0], 2) + Math.pow(existing[1] - newCircle[1], 2));
                        return dist < minDist / 2;
                    });
                    if (!isDuplicate) {
                        allCircles.push(newCircle);
                    }
                }
            }

            const imageKey = imageIndex >= 0 ? `image_${imageIndex}` : getCurrentImageKey();
            if (!shapesByImage[imageKey]) {
                shapesByImage[imageKey] = [];
            }

            // Remove previous auto-detected shapes
            shapesByImage[imageKey] = shapesByImage[imageKey].filter(s => !s.auto);

            if (allCircles.length > 0) {
                // ENHANCED: Sort circles based on user preference
                let sortOrder = document.getElementById('circleSortOrder').value;
                if (sortOrder === 'topDown') {
                    allCircles.sort((a, b) => a[1] - b[1]); // Sort by Y coordinate
                } else if (sortOrder === 'leftRight') {
                    allCircles.sort((a, b) => a[0] - b[0]); // Sort by X coordinate
                }

                allCircles.forEach(([x, y, r]) => {
                    let restrictedPercentage = parseInt(document.getElementById('restrictedAreaVal').value, 10);
                    let effectiveR = Math.round(r * (restrictedPercentage / 100));

                    // Enhanced color extraction with multiple sampling methods
                    let mask = new cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC1);
                    let center = new cv.Point(x, y);
                    cv.circle(mask, center, effectiveR, new cv.Scalar(255, 255, 255, 255), -1);
                    
                    let mean = cv.mean(src, mask);
                    let avgRGB = [
                        formatColorValue(mean[0]), 
                        formatColorValue(mean[1]), 
                        formatColorValue(mean[2])
                    ];

                    shapesByImage[imageKey].push({
                        type: "circle",
                        coords: [Math.round(x), Math.round(y), effectiveR],
                        color: avgRGB,
                        auto: true,
                        label: getNextAvailableLabel(),
                        imageKey: imageKey
                    });
                    mask.delete();
                });
                
                if (isGridView) {
                    updateGridView();
                } else {
                    updateCurrentShapes();
                }
                updateShapeList();
            } else {
                if (!isGridView) {
                    let err = document.getElementById('noCirclesMsg');
                    err.style.display = "block";
                    setTimeout(() => { err.style.display = "none"; }, 2000);
                }
            }

            // Cleanup
            src.delete();
            gray.delete();
            bilateral.delete();
            enhanced.delete();
            blur.delete();
            edges.delete();
            circles.delete();
        }

        // ENHANCED regression calculation with axis swap support
        function calculateEnhancedRegression(pts, component) {
            const n = pts.length;
            if (n < 2) return null;

            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;

            pts.forEach(pt => {
                let x, y;
                
                if (axesSwapped) {
                    // X: Concentration, Y: Color
                    x = parseFloat(pt.y);
                    y = parseFloat(pt[component]);
                } else {
                    // X: Color, Y: Concentration
                    x = parseFloat(pt[component]);
                    y = parseFloat(pt.y);
                }
                
                if (isNaN(x) || isNaN(y)) return;
                
                sumX += x;
                sumY += y;
                sumXY += x * y;
                sumX2 += x * x;
                sumY2 += y * y;
            });

            const denominator = n * sumX2 - sumX * sumX;
            if (Math.abs(denominator) < 1e-12) return null;

            const slope = (n * sumXY - sumX * sumY) / denominator;
            const intercept = (sumY - slope * sumX) / n;

            // Calculate R²
            let ssTot = 0, ssRes = 0;
            const meanY = sumY / n;
            
            pts.forEach(pt => {
                let x, y;
                
                if (axesSwapped) {
                    x = parseFloat(pt.y);
                    y = parseFloat(pt[component]);
                } else {
                    x = parseFloat(pt[component]);
                    y = parseFloat(pt.y);
                }
                
                if (isNaN(x) || isNaN(y)) return;
                
                const predicted = slope * x + intercept;
                ssTot += Math.pow(y - meanY, 2);
                ssRes += Math.pow(y - predicted, 2);
            });

            const r2 = ssTot > 0 ? Math.max(0, Math.min(1, 1 - ssRes / ssTot)) : 0;

            return { 
                m: slope, 
                b: intercept, 
                r2: r2 
            };
        }

        // Proper canvas sizing with aspect ratio
        function resizeCanvasToAspect() {
            const container = document.getElementById('container');
            const containerRect = container.getBoundingClientRect();
            
            let sourceWidth, sourceHeight;
            if (imageMode && loadedImages.length > 0) {
                const img = loadedImages[currentImageIndex];
                sourceWidth = img.width;
                sourceHeight = img.height;
            } else if (video.videoWidth && video.videoHeight) {
                sourceWidth = video.videoWidth;
                sourceHeight = video.videoHeight;
            } else {
                sourceWidth = 640;
                sourceHeight = 480;
            }

            const sourceAspect = sourceWidth / sourceHeight;
            const containerAspect = containerRect.width / containerRect.height;

            let canvasWidth, canvasHeight;
            
            if (sourceAspect > containerAspect) {
                canvasWidth = containerRect.width * 0.8;
                canvasHeight = canvasWidth / sourceAspect;
            } else {
                canvasHeight = containerRect.height * 0.8;
                canvasWidth = canvasHeight * sourceAspect;
            }

            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            baseCanvasSize = { width: canvasWidth, height: canvasHeight };
        }

        function drawImageWithAspect(ctx, img, canvasWidth, canvasHeight) {
            let imgWidth = img.videoWidth || img.width;
            let imgHeight = img.videoHeight || img.height;
            let imgAspect = imgWidth / imgHeight;
            let canvasAspect = canvasWidth / canvasHeight;
            let drawWidth, drawHeight, offsetX, offsetY;

            if (imgAspect > canvasAspect) {
                drawWidth = canvasWidth;
                drawHeight = canvasWidth / imgAspect;
                offsetX = 0;
                offsetY = (canvasHeight - drawHeight) / 2;
            } else {
                drawHeight = canvasHeight;
                drawWidth = canvasHeight * imgAspect;
                offsetY = 0;
                offsetX = (canvasWidth - drawWidth) / 2;
            }

            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
            return { offsetX, offsetY, scale: drawWidth / imgWidth };
        }

        function getCurrentFrame() {
            let tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            let tempCtx = tempCanvas.getContext('2d');

            if (imageMode && loadedImages.length > 0) {
                drawImageWithAspect(tempCtx, loadedImages[currentImageIndex], tempCanvas.width, tempCanvas.height);
            } else {
                drawImageWithAspect(tempCtx, video, tempCanvas.width, tempCanvas.height);
            }

            return tempCanvas;
        }

        // Enhanced color computation
        function computeAverageForRectangle(rect) {
            let frameCanvas = getCurrentFrame();
            let tempCtx = frameCanvas.getContext('2d');
            let data = tempCtx.getImageData(0, 0, frameCanvas.width, frameCanvas.height).data;
            let [x1, y1, x2, y2] = rect;
            let sum = [0, 0, 0], count = 0;

            for (let y = Math.max(0, y1); y < Math.min(frameCanvas.height, y2); y++) {
                for (let x = Math.max(0, x1); x < Math.min(frameCanvas.width, x2); x++) {
                    let idx = (y * frameCanvas.width + x) * 4;
                    if (idx + 2 < data.length) {
                        sum[0] += data[idx];
                        sum[1] += data[idx + 1];
                        sum[2] += data[idx + 2];
                        count++;
                    }
                }
            }

            if (count === 0) return [0, 0, 0];
            return [
                formatColorValue(sum[0] / count),
                formatColorValue(sum[1] / count),
                formatColorValue(sum[2] / count)
            ];
        }

        function computeAverageForCircle(circle) {
            let frameCanvas = getCurrentFrame();
            let tempCtx = frameCanvas.getContext('2d');
            let data = tempCtx.getImageData(0, 0, frameCanvas.width, frameCanvas.height).data;
            let [cx, cy, r] = circle;

            let restrictedPercentage = parseInt(document.getElementById('restrictedAreaVal').value, 10) || 100;
            let effectiveRadius = r * (restrictedPercentage / 100);

            let sum = [0, 0, 0], count = 0;
            
            for (let y = Math.max(0, Math.floor(cy - effectiveRadius)); 
                 y <= Math.min(frameCanvas.height - 1, Math.floor(cy + effectiveRadius)); y++) {
                for (let x = Math.max(0, Math.floor(cx - effectiveRadius)); 
                     x <= Math.min(frameCanvas.width - 1, Math.floor(cx + effectiveRadius)); x++) {
                    let dx = x - cx, dy = y - cy;
                    if (dx * dx + dy * dy <= effectiveRadius * effectiveRadius) {
                        let idx = (y * frameCanvas.width + x) * 4;
                        if (idx + 2 < data.length) {
                            sum[0] += data[idx];
                            sum[1] += data[idx + 1];
                            sum[2] += data[idx + 2];
                            count++;
                        }
                    }
                }
            }

            if (count === 0) return [0, 0, 0];
            return [
                formatColorValue(sum[0] / count),
                formatColorValue(sum[1] / count),
                formatColorValue(sum[2] / count)
            ];
        }

        function generateSpeciesIcon(shape) {
            let tempCanvas = document.createElement('canvas');
            tempCanvas.width = 40;
            tempCanvas.height = 40;
            let tempCtx = tempCanvas.getContext('2d');

            let sourceCanvas;
            if (shape.imageKey && shape.imageKey.startsWith('image_')) {
                const imageIndex = parseInt(shape.imageKey.split('_')[1]);
                if (imageIndex >= 0 && imageIndex < loadedImages.length) {
                    sourceCanvas = document.createElement('canvas');
                    sourceCanvas.width = canvas.width;
                    sourceCanvas.height = canvas.height;
                    const sourceCtx = sourceCanvas.getContext('2d');
                    drawImageWithAspect(sourceCtx, loadedImages[imageIndex], sourceCanvas.width, sourceCanvas.height);
                } else {
                    sourceCanvas = getCurrentFrame();
                }
            } else {
                sourceCanvas = getCurrentFrame();
            }

            if (shape.type === "rectangle") {
                let [x1, y1, x2, y2] = shape.coords;
                let width = Math.max(1, x2 - x1);
                let height = Math.max(1, y2 - y1);
                
                try {
                    let sourceData = sourceCanvas.getContext('2d').getImageData(
                        Math.max(0, x1), Math.max(0, y1), 
                        Math.min(width, sourceCanvas.width - x1), 
                        Math.min(height, sourceCanvas.height - y1)
                    );

                    let scale = Math.min(40 / width, 40 / height);
                    let scaledWidth = width * scale;
                    let scaledHeight = height * scale;
                    let offsetX = (40 - scaledWidth) / 2;
                    let offsetY = (40 - scaledHeight) / 2;

                    tempCtx.fillStyle = "#222";
                    tempCtx.fillRect(0, 0, 40, 40);
                    
                    let dataCanvas = document.createElement('canvas');
                    dataCanvas.width = sourceData.width;
                    dataCanvas.height = sourceData.height;
                    let dataCtx = dataCanvas.getContext('2d');
                    dataCtx.putImageData(sourceData, 0, 0);

                    tempCtx.drawImage(dataCanvas, offsetX, offsetY, scaledWidth, scaledHeight);
                } catch (e) {
                    tempCtx.fillStyle = `rgb(${shape.color[0]}, ${shape.color[1]}, ${shape.color[2]})`;
                    tempCtx.fillRect(0, 0, 40, 40);
                }
            } else if (shape.type === "circle") {
                let [cx, cy, r] = shape.coords;
                
                try {
                    let diameter = Math.max(1, r * 2);
                    let sourceData = sourceCanvas.getContext('2d').getImageData(
                        Math.max(0, cx - r), Math.max(0, cy - r), 
                        Math.min(diameter, sourceCanvas.width - (cx - r)), 
                        Math.min(diameter, sourceCanvas.height - (cy - r))
                    );

                    let scale = Math.min(40 / diameter, 40 / diameter);
                    let scaledSize = diameter * scale;
                    let offset = (40 - scaledSize) / 2;

                    tempCtx.fillStyle = "#222";
                    tempCtx.fillRect(0, 0, 40, 40);
                    
                    let dataCanvas = document.createElement('canvas');
                    dataCanvas.width = sourceData.width;
                    dataCanvas.height = sourceData.height;
                    let dataCtx = dataCanvas.getContext('2d');
                    dataCtx.putImageData(sourceData, 0, 0);

                    tempCtx.drawImage(dataCanvas, offset, offset, scaledSize, scaledSize);
                } catch (e) {
                    tempCtx.fillStyle = `rgb(${shape.color[0]}, ${shape.color[1]}, ${shape.color[2]})`;
                    tempCtx.beginPath();
                    tempCtx.arc(20, 20, 18, 0, 2 * Math.PI);
                    tempCtx.fill();
                }
            }

            return tempCanvas.toDataURL();
        }

        // Returns CMYK from an RGB array
        function rgbToCmyk(rgb) {
            let [r, g, b] = rgb.map(v => parseFloat(v));
            if (r === 0 && g === 0 && b === 0) return [0, 0, 0, 100].map(formatColorValue);
            
            let rNorm = r / 255, gNorm = g / 255, bNorm = b / 255;
            let k = 1 - Math.max(rNorm, gNorm, bNorm);
            
            if (k === 1) return [0, 0, 0, 100].map(formatColorValue);
            
            let c = (1 - rNorm - k) / (1 - k);
            let m = (1 - gNorm - k) / (1 - k);
            let y = (1 - bNorm - k) / (1 - k);
            
            return [
                formatColorValue(c * 100), 
                formatColorValue(m * 100), 
                formatColorValue(y * 100), 
                formatColorValue(k * 100)
            ];
        }

        // Draw all finalized shapes and current shape being drawn
        function drawSelections(ctx) {
            let removalSelect = document.getElementById('circleSelect');
            let selectedLabel = removalSelect ? removalSelect.value : null;

            shapes.forEach(shape => {
                let label = shape.label;
                if (shape.type === "rectangle") {
                    let [x1, y1, x2, y2] = shape.coords;
                    ctx.fillStyle = "rgba(50,200,50,0.2)";
                    ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
                    ctx.strokeStyle = "rgb(0,255,100)";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);

                    let colorText = (colorMode === "CMYK") ?
                        `CMYK: ${rgbToCmyk(shape.color).join(', ')}` :
                        `RGB: ${shape.color.map(v => formatColorValue(v)).join(', ')}`;
                    let text = `${label}: ${colorText}`;
                    ctx.font = "14px 'Segoe UI', Arial, sans-serif";
                    ctx.fillStyle = `rgb(${shape.color[0]}, ${shape.color[1]}, ${shape.color[2]})`;
                    ctx.fillText(text, x1, y1 - 8);

                    if (label === selectedLabel) {
                        ctx.strokeStyle = "red";
                        ctx.lineWidth = 4;
                        ctx.strokeRect(x1 - 2, y1 - 2, (x2 - x1) + 4, (y2 - y1) + 4);
                    }
                } else if (shape.type === "circle") {
                    let [cx, cy, r] = shape.coords;
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = "lime";
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(cx, cy, 3, 0, 2 * Math.PI);
                    ctx.fillStyle = "red";
                    ctx.fill();

                    let colorText = (colorMode === "CMYK") ?
                        `CMYK: ${rgbToCmyk(shape.color).join(', ')}` :
                        `RGB: ${shape.color.map(v => formatColorValue(v)).join(', ')}`;
                    let text = `${label}: ${colorText}`;
                    ctx.font = "14px 'Segoe UI', Arial, sans-serif";
                    ctx.fillStyle = `rgb(${shape.color[0]}, ${shape.color[1]}, ${shape.color[2]})`;
                    ctx.fillText(text, cx + r + 10, cy);

                    if (label === selectedLabel) {
                        ctx.beginPath();
                        ctx.arc(cx, cy, r + 3, 0, 2 * Math.PI);
                        ctx.strokeStyle = "red";
                        ctx.lineWidth = 4;
                        ctx.stroke();
                    }
                }
            });

            // Draw the temporary shape currently being drawn
            if (currentShape) {
                if (currentShape.type === "rectangle") {
                    let [x1, y1, x2, y2] = currentShape.coords;
                    ctx.fillStyle = "rgba(50,200,50,0.2)";
                    ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
                    ctx.strokeStyle = "rgb(0,255,100)";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                } else if (currentShape.type === "circle") {
                    let [cx, cy, r] = currentShape.coords;
                    ctx.fillStyle = "rgba(50,200,50,0.2)";
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = "rgb(0,255,100)";
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(cx - 5, cy);
                    ctx.lineTo(cx + 5, cy);
                    ctx.moveTo(cx, cy - 5);
                    ctx.lineTo(cx, cy + 5);
                    ctx.stroke();
                }
            }
        }

        // Returns canvas coordinates adjusted for zoom
        function getMappedCoordinates(e) {
            let rect = canvas.getBoundingClientRect();
            let x = Math.floor((e.clientX - rect.left) / zoomLevel);
            let y = Math.floor((e.clientY - rect.top) / zoomLevel);
            return [x, y];
        }

        function mainLoop() {
            if (isGridView) {
                requestAnimationFrame(mainLoop);
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (imageMode && loadedImages.length > 0) {
                drawImageWithAspect(ctx, loadedImages[currentImageIndex], canvas.width, canvas.height);
            } else {
                drawImageWithAspect(ctx, video, canvas.width, canvas.height);
            }

            drawSelections(ctx);

            // Update color display with current cursor color
            let tempFrame = getCurrentFrame();
            let tempCtx = tempFrame.getContext('2d');
            let x = Math.floor(currentMousePos.x / zoomLevel);
            let y = Math.floor(currentMousePos.y / zoomLevel);
            let cursorColor = [0, 0, 0];

            if (x >= 0 && y >= 0 && x < tempFrame.width && y < tempFrame.height) {
                let pixel = tempCtx.getImageData(x, y, 1, 1).data;
                cursorColor = [pixel[0], pixel[1], pixel[2]];
            }

            // Update color display
            let colorText = (colorMode === "CMYK") ?
                `CMYK: ${rgbToCmyk(cursorColor).join(', ')}` :
                `RGB: ${cursorColor.map(v => formatColorValue(v)).join(', ')}`;
                
            const colorDisplay = document.getElementById('colorDisplay');
            colorDisplay.innerHTML = `
                <div style="margin-bottom: 4px;">${colorText}</div>
                <div style="font-size: 10px; color: rgba(255,255,255,0.7);">
                    [1]Rect [2]Circle [C]Capture [O]Open [R]Reset [A]Auto
                </div>
            `;

            requestAnimationFrame(mainLoop);
        }

        // CALIBRATED grid canvas interaction setup
        function setupGridCanvasInteraction(canvas, imageIndex) {
            let isDragging = false;
            let startPos = null;
            let tempShape = null;

            function getGridCanvasCoords(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                return {
                    x: Math.floor((e.clientX - rect.left) * scaleX),
                    y: Math.floor((e.clientY - rect.top) * scaleY)
                };
            }

            canvas.addEventListener('mousedown', function(e) {
                e.preventDefault();
                const pos = getGridCanvasCoords(e);
                if (e.button === 0) {
                    isDragging = true;
                    startPos = pos;
                }
            });

            canvas.addEventListener('mousemove', function(e) {
                if (!isDragging || !startPos) return;
                
                const pos = getGridCanvasCoords(e);
                const ctx = canvas.getContext('2d');
                
                const img = loadedImages[imageIndex];
                drawImageWithAspect(ctx, img, canvas.width, canvas.height);
                
                const imageKey = `image_${imageIndex}`;
                if (shapesByImage[imageKey]) {
                    shapesByImage[imageKey].forEach(shape => {
                        drawShapeOnCanvas(ctx, shape, canvas.width, canvas.height);
                    });
                }
                
                if (selectionMode === "rectangle") {
                    const x1 = Math.min(startPos.x, pos.x);
                    const y1 = Math.min(startPos.y, pos.y);
                    const x2 = Math.max(startPos.x, pos.x);
                    const y2 = Math.max(startPos.y, pos.y);
                    
                    ctx.fillStyle = "rgba(50,200,50,0.2)";
                    ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
                    ctx.strokeStyle = "rgb(0,255,100)";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                    
                    tempShape = {
                        type: "rectangle",
                        coords: [x1, y1, x2, y2]
                    };
                } else if (selectionMode === "circle") {
                    const dx = pos.x - startPos.x;
                    const dy = pos.y - startPos.y;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    
                    ctx.fillStyle = "rgba(50,200,50,0.2)";
                    ctx.beginPath();
                    ctx.arc(startPos.x, startPos.y, r, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = "rgb(0,255,100)";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    tempShape = {
                        type: "circle",
                        coords: [startPos.x, startPos.y, r]
                    };
                }
            });

            canvas.addEventListener('mouseup', function(e) {
                if (!isDragging || !startPos || !tempShape) {
                    isDragging = false;
                    startPos = null;
                    tempShape = null;
                    return;
                }
                
                isDragging = false;
                
                const imageKey = `image_${imageIndex}`;
                if (!shapesByImage[imageKey]) {
                    shapesByImage[imageKey] = [];
                }
                
                let avg;
                if (tempShape.type === "rectangle") {
                    avg = computeAverageForGridRectangle(tempShape.coords, canvas, loadedImages[imageIndex]);
                } else {
                    avg = computeAverageForGridCircle(tempShape.coords, canvas, loadedImages[imageIndex]);
                }
                
                shapesByImage[imageKey].push({
                    type: tempShape.type,
                    coords: tempShape.coords,
                    color: avg,
                    auto: false,
                    label: getNextAvailableLabel(),
                    imageKey: imageKey
                });
                
                updateGridView();
                updateShapeList();
                
                startPos = null;
                tempShape = null;
            });
        }

        function drawShapeOnCanvas(ctx, shape, canvasWidth, canvasHeight) {
            if (shape.type === "rectangle") {
                let [x1, y1, x2, y2] = shape.coords;
                ctx.fillStyle = "rgba(50,200,50,0.2)";
                ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
                ctx.strokeStyle = "rgb(0,255,100)";
                ctx.lineWidth = 2;
                ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                
                ctx.font = "11px Arial";
                ctx.fillStyle = "white";
                ctx.strokeStyle = "black";
                ctx.lineWidth = 1;
                ctx.strokeText(shape.label, x1 + 2, y1 - 4);
                ctx.fillText(shape.label, x1 + 2, y1 - 4);
            } else if (shape.type === "circle") {
                let [cx, cy, r] = shape.coords;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                ctx.lineWidth = 2;
                ctx.strokeStyle = "lime";
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(cx, cy, 2, 0, 2 * Math.PI);
                ctx.fillStyle = "red";
                ctx.fill();
                
                ctx.font = "11px Arial";
                ctx.fillStyle = "white";
                ctx.strokeStyle = "black";
                ctx.lineWidth = 1;
                ctx.strokeText(shape.label, cx + r + 3, cy);
                ctx.fillText(shape.label, cx + r + 3, cy);
            }
        }

        // CALIBRATED grid view color computation
        function computeAverageForGridRectangle(coords, canvas, img) {
            const [x1, y1, x2, y2] = coords;
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            drawImageWithAspect(tempCtx, img, tempCanvas.width, tempCanvas.height);
            
            const data = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;
            let sum = [0, 0, 0], count = 0;

            for (let y = Math.max(0, y1); y < Math.min(tempCanvas.height, y2); y++) {
                for (let x = Math.max(0, x1); x < Math.min(tempCanvas.width, x2); x++) {
                    let idx = (y * tempCanvas.width + x) * 4;
                    if (idx + 2 < data.length) {
                        sum[0] += data[idx];
                        sum[1] += data[idx + 1];
                        sum[2] += data[idx + 2];
                        count++;
                    }
                }
            }

            if (count === 0) return [0, 0, 0];
            return [
                formatColorValue(sum[0] / count),
                formatColorValue(sum[1] / count),
                formatColorValue(sum[2] / count)
            ];
        }

        function computeAverageForGridCircle(coords, canvas, img) {
            const [cx, cy, r] = coords;
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            drawImageWithAspect(tempCtx, img, tempCanvas.width, tempCanvas.height);
            
            const data = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;
            let sum = [0, 0, 0], count = 0;

            const restrictedPercentage = parseInt(document.getElementById('restrictedAreaVal').value, 10) || 100;
            const effectiveR = r * (restrictedPercentage / 100);

            for (let y = Math.max(0, Math.floor(cy - effectiveR)); 
                 y <= Math.min(tempCanvas.height - 1, Math.floor(cy + effectiveR)); y++) {
                for (let x = Math.max(0, Math.floor(cx - effectiveR)); 
                     x <= Math.min(tempCanvas.width - 1, Math.floor(cx + effectiveR)); x++) {
                    let dx = x - cx, dy = y - cy;
                    if (dx * dx + dy * dy <= effectiveR * effectiveR) {
                        let idx = (y * tempCanvas.width + x) * 4;
                        if (idx + 2 < data.length) {
                            sum[0] += data[idx];
                            sum[1] += data[idx + 1];
                            sum[2] += data[idx + 2];
                            count++;
                        }
                    }
                }
            }

            if (count === 0) return [0, 0, 0];
            return [
                formatColorValue(sum[0] / count),
                formatColorValue(sum[1] / count),
                formatColorValue(sum[2] / count)
            ];
        }

        // ENHANCED: Interactive tooltip system
        function showPointTooltip(e, pt, xVal, yVal, component) {
            hidePointTooltip();
            
            currentTooltip = document.createElement('div');
            currentTooltip.className = 'chart-tooltip';
            currentTooltip.style.cssText = `
                position: fixed;
                background: rgba(0, 0, 0, 0.9);
                color: white;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 12px;
                pointer-events: none;
                z-index: 10000;
                border: 1px solid #4a90e2;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            `;
            
            currentTooltip.innerHTML = `
                <div><strong>Species:</strong> ${pt.label}</div>
                <div><strong>X:</strong> ${xVal.toFixed(3)}</div>
                <div><strong>Y:</strong> ${yVal.toFixed(3)}</div>
                <div><strong>Component:</strong> ${component}</div>
            `;
            
            document.body.appendChild(currentTooltip);
            
            const rect = currentTooltip.getBoundingClientRect();
            currentTooltip.style.left = (e.clientX - rect.width / 2) + 'px';
            currentTooltip.style.top = (e.clientY - rect.height - 10) + 'px';
        }

        function hidePointTooltip() {
            if (currentTooltip) {
                document.body.removeChild(currentTooltip);
                currentTooltip = null;
            }
        }

        // ENHANCED: Chart drawing with proper axis swapping and interactive features
        function drawComponentChart(component, pts, model) {
            const canvasId = component + 'Chart';
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const W = canvas.width, H = canvas.height;
            const pad = 35;

            ctx.clearRect(0, 0, W, H);
            ctx.fillStyle = "#111";
            ctx.fillRect(0, 0, W, H);

            // ENHANCED: Proper axis swapping logic
            let xValues, yValues, xLabel, yLabel;
            if (axesSwapped) {
                // X: Concentration, Y: Color
                xValues = pts.map(p => p.y);
                yValues = pts.map(p => p[component]);
                xLabel = 'Concentration (M)';
                yLabel = component.charAt(0).toUpperCase() + component.slice(1) + ' Value';
            } else {
                // X: Color, Y: Concentration
                xValues = pts.map(p => p[component]);
                yValues = pts.map(p => p.y);
                xLabel = component.charAt(0).toUpperCase() + component.slice(1) + ' Value';
                yLabel = 'Concentration (M)';
            }

            const xMin = Math.min(...xValues);
            const xMax = Math.max(...xValues);
            const yMin = Math.min(...yValues);
            const yMax = Math.max(...yValues);

            const xRange = xMax - xMin || 1;
            const yRange = yMax - yMin || 1;
            const xPad = xRange * 0.1;
            const yPad = yRange * 0.1;

            const toX = x => pad + ((x - (xMin - xPad)) / (xRange + 2 * xPad)) * (W - 2 * pad);
            const toY = y => H - pad - ((y - (yMin - yPad)) / (yRange + 2 * yPad)) * (H - 2 * pad);

            // ENHANCED: Draw grid with scale labels if enabled
            const showScales = document.getElementById('showScalesToggle').checked;
            if (showScales) {
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 1;
                ctx.fillStyle = "#aaa";
                ctx.font = "10px 'Segoe UI', Arial, sans-serif";
                ctx.textAlign = "center";

                for (let i = 0; i <= 5; i++) {
                    const x = pad + (i / 5) * (W - 2 * pad);
                    const y = pad + (i / 5) * (H - 2 * pad);
                    
                    // Vertical grid lines with X-axis labels
                    ctx.beginPath();
                    ctx.moveTo(x, pad);
                    ctx.lineTo(x, H - pad);
                    ctx.stroke();
                    
                    const xVal = (xMin - xPad) + (i / 5) * (xRange + 2 * xPad);
                    ctx.fillText(xVal.toFixed(2), x, H - pad + 15);
                    
                    // Horizontal grid lines with Y-axis labels
                    ctx.beginPath();
                    ctx.moveTo(pad, y);
                    ctx.lineTo(W - pad, y);
                    ctx.stroke();
                    
                    const yVal = (yMax + yPad) - (i / 5) * (yRange + 2 * yPad);
                    ctx.textAlign = "right";
                    ctx.fillText(yVal.toFixed(2), pad - 5, y + 3);
                    ctx.textAlign = "center";
                }
            }

            // Draw axes
            ctx.strokeStyle = "#ccc";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(pad, H - pad);
            ctx.lineTo(W - pad, H - pad);
            ctx.moveTo(pad, H - pad);
            ctx.lineTo(pad, pad);
            ctx.stroke();

            // ENHANCED: Interactive data points with hover detection
            const pointRadius = 6;
            const hoverRadius = 10;
            
            pts.forEach((pt, index) => {
                const x = toX(xValues[index]);
                const y = toY(yValues[index]);
                
                // Store point data for hover detection
                canvas.addEventListener('mousemove', function(e) {
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    const distance = Math.sqrt(Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2));
                    
                    if (distance <= hoverRadius) {
                        showPointTooltip(e, pt, xValues[index], yValues[index], component);
                    } else {
                        hidePointTooltip();
                    }
                });
                
                ctx.beginPath();
                ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
                ctx.fillStyle = "#4a90e2";
                ctx.fill();
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // ENHANCED: Toggleable regression line and R² display
            const showRegression = document.getElementById('showRegressionToggle').checked;
            if (showRegression && model && model.m !== undefined && model.b !== undefined) {
                ctx.strokeStyle = "#ff6b6b";
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                const x1 = xMin - xPad;
                const x2 = xMax + xPad;
                let y1, y2;
                
                if (axesSwapped) {
                    y1 = (x1 - model.b) / model.m;
                    y2 = (x2 - model.b) / model.m;
                } else {
                    y1 = model.m * x1 + model.b;
                    y2 = model.m * x2 + model.b;
                }
                
                ctx.moveTo(toX(x1), toY(y1));
                ctx.lineTo(toX(x2), toY(y2));
                ctx.stroke();

                // Display equation and R²
                ctx.fillStyle = "#ff6b6b";
                ctx.font = "11px 'Segoe UI', Arial, sans-serif";
                ctx.textAlign = "right";
                
                const interceptSign = model.b >= 0 ? '+' : '-';
                const interceptValue = Math.abs(model.b);
                
                ctx.fillText(`y = ${model.m.toFixed(6)}x ${interceptSign} ${interceptValue.toFixed(6)}`, W - 10, 20);
                ctx.fillText(`R² = ${model.r2.toFixed(4)}`, W - 10, 35);
            }

            // ENHANCED: Proper axis labels
            ctx.fillStyle = "#eee";
            ctx.font = "12px 'Segoe UI', Arial, sans-serif";
            ctx.textAlign = "center";
            ctx.fillText(xLabel, W / 2, H - 8);

            ctx.save();
            ctx.translate(12, H / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(yLabel, 0, 0);
            ctx.restore();
        }

        // OpenCV ready callback
        function onOpenCvReady() {
            console.log("OpenCV.js is ready.");
            startVideo();
        }

        function startVideo() {
            navigator.mediaDevices.getUserMedia({ video: true, audio: false })
                .then(function (stream) {
                    video.srcObject = stream;
                    video.play();
                })
                .catch(function (err) {
                    console.error("Error accessing webcam: " + err);
                });

            video.addEventListener('canplay', function () {
                if (!streaming) {
                    streaming = true;
                    resizeCanvasToAspect();
                    updateCurrentShapes();
                    requestAnimationFrame(mainLoop);
                }
            });

            window.addEventListener('resize', function() {
                if (streaming && !isGridView) {
                    resizeCanvasToAspect();
                }
            });
        }

        // Mouse events for drawing shapes
        canvas.addEventListener('mousedown', function (e) {
            if (isGridView) return;
            let pos = getMappedCoordinates(e);
            if (!pos) return;
            if (e.button === 0) {
                currentDrag = pos;
            }
        });

        canvas.addEventListener('mousemove', function (e) {
            if (isGridView) return;
            let pos = getMappedCoordinates(e);
            currentMousePos = { x: pos[0], y: pos[1] };

            if (!currentDrag) return;

            if (selectionMode === "rectangle") {
                let x1 = currentDrag[0], y1 = currentDrag[1];
                let x2 = pos[0], y2 = pos[1];
                currentShape = {
                    type: "rectangle",
                    coords: [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)]
                };
            } else if (selectionMode === "circle") {
                let dx = pos[0] - currentDrag[0], dy = pos[1] - currentDrag[1];
                let r = Math.floor(Math.sqrt(dx * dx + dy * dy));
                currentShape = {
                    type: "circle",
                    coords: [currentDrag[0], currentDrag[1], r]
                };
            }
        });

        canvas.addEventListener('mouseup', function (e) {
            if (isGridView) return;
            if (e.button !== 0) return;
            let pos = getMappedCoordinates(e);
            if (!currentDrag || !pos) {
                currentDrag = null;
                currentShape = null;
                return;
            }

            const imageKey = getCurrentImageKey();
            if (!shapesByImage[imageKey]) {
                shapesByImage[imageKey] = [];
            }

            if (selectionMode === "rectangle" && currentShape) {
                let rect = currentShape.coords;
                let avg = computeAverageForRectangle(rect);
                shapesByImage[imageKey].push({
                    type: "rectangle",
                    coords: rect,
                    color: avg,
                    auto: false,
                    label: getNextAvailableLabel(),
                    imageKey: imageKey
                });
            } else if (selectionMode === "circle" && currentShape) {
                let circle = currentShape.coords;
                let avg = computeAverageForCircle(circle);
                shapesByImage[imageKey].push({
                    type: "circle",
                    coords: circle,
                    color: avg,
                    auto: false,
                    label: getNextAvailableLabel(),
                    imageKey: imageKey
                });
            }

            updateCurrentShapes();
            updateShapeList();
            currentDrag = null;
            currentShape = null;
        });

        // Mouse wheel zoom
        canvas.addEventListener('wheel', function(e) {
            if (isGridView) return;
            e.preventDefault();
            
            if (e.deltaY < 0) {
                zoomIn();
            } else {
                zoomOut();
            }
        });

        // Prevent context menu
        canvas.addEventListener('contextmenu', function (e) {
            e.preventDefault();
        });

        // ENHANCED: Reset functionality for grid mode
        function resetAllGridShapes() {
            Object.keys(shapesByImage).forEach(imageKey => {
                if (shapesByImage[imageKey]) {
                    shapesByImage[imageKey].forEach(shape => {
                        recycleLabel(shape.label);
                    });
                    shapesByImage[imageKey] = [];
                }
            });
            updateCurrentShapes();
            updateGridView();
            updateShapeList();
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function (e) {
            let key = e.key.toLowerCase();

            if (key === '1') {
                selectionMode = "rectangle";
            } else if (key === '2') {
                selectionMode = "circle";
            } else if (key === 'g') {
                toggleGridView();
            } else if (key === 'c') {
                if (e.ctrlKey) return;
                let timestamp = new Date().toISOString().replace(/[:\-T.]/g, '');
                let dataURL = canvas.toDataURL('image/png');
                let link = document.createElement('a');
                link.download = `capture_${timestamp}.png`;
                link.href = dataURL;
                link.click();
                console.log(`Captured image at ${timestamp}`);
            } else if (key === 'o') {
                fileInput.click();
            } else if (key === 'r') {
                if (isGridView) {
                    resetAllGridShapes();
                } else {
                    const imageKey = getCurrentImageKey();
                    if (shapesByImage[imageKey]) {
                        shapesByImage[imageKey].forEach(shape => {
                            recycleLabel(shape.label);
                        });
                        shapesByImage[imageKey] = [];
                    }
                    updateCurrentShapes();
                    updateShapeList();
                }
            } else if (key === 'a') {
                if (isGridView) {
                    autoDetectAllImages();
                } else {
                    const imageKey = getCurrentImageKey();
                    if (imageKey.startsWith('image_')) {
                        const imageIndex = parseInt(imageKey.split('_')[1]);
                        autoDetectOnImage(imageIndex);
                    } else {
                        autoDetectOnImage(-1);
                    }
                }
            }
        });

        // Event listeners setup
        document.getElementById('gridToggleBtn').addEventListener('click', toggleGridView);
        document.getElementById('autoDetectAllBtn').addEventListener('click', autoDetectAllImages);
        document.getElementById('resetAllGridBtn').addEventListener('click', resetAllGridShapes);
        
        // Zoom controls
        document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
        document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
        document.getElementById('zoomResetBtn').addEventListener('click', resetZoom);
        
        document.getElementById('precisionSelector').addEventListener('change', function() {
            decimalPrecision = parseInt(this.value, 10);
            updateRegressionTable();
        });

        // ENHANCED: Axis swap functionality
        document.getElementById('axisSwapSelector').addEventListener('change', function() {
            axesSwapped = this.value === 'swapped';
            computeMultipleRegressions(); // Redraw charts with new axes
        });

        // ENHANCED: Chart display controls
        document.getElementById('showRegressionToggle').addEventListener('change', function() {
            computeMultipleRegressions(); // Redraw charts with/without regression
        });

        document.getElementById('showScalesToggle').addEventListener('change', function() {
            computeMultipleRegressions(); // Redraw charts with/without scales
        });

        document.getElementById('circleSortOrder').addEventListener('change', function() {
            // Re-run auto-detection with new sorting when changed
            if (isGridView) {
                // Don't auto-run in grid view to avoid disruption
            }
        });

        fileInput.addEventListener('change', function (e) {
            let files = Array.from(e.target.files);
            if (files.length === 0) return;

            files.forEach(file => {
                let imgElem = new Image();
                imgElem.onload = function () {
                    loadedImages.push(imgElem);
                    if (loadedImages.length === 1) {
                        imageMode = true;
                        currentImageIndex = 0;
                        resizeCanvasToAspect();
                        updateCurrentShapes();
                    }
                    updateImageThumbnails();
                    if (isGridView) {
                        updateGridView();
                    }
                };
                imgElem.src = URL.createObjectURL(file);
            });
        });

        document.getElementById('addImagesBtn').addEventListener('click', function () {
            fileInput.click();
        });

        function updateImageThumbnails() {
            let container = document.getElementById('imageThumbnails');
            container.innerHTML = '';

            loadedImages.forEach((img, index) => {
                let thumbnail = document.createElement('img');
                thumbnail.src = img.src;
                thumbnail.style.cssText = `
                    width: 60px; height: 40px; object-fit: contain; 
                    border: 2px solid #555; border-radius: 4px; margin: 2px; 
                    cursor: pointer; transition: all 0.3s; background: #222;
                `;
                if (index === currentImageIndex) {
                    thumbnail.style.borderColor = '#4a90e2';
                    thumbnail.style.boxShadow = '0 0 8px rgba(74, 144, 226, 0.5)';
                }
                thumbnail.addEventListener('click', () => {
                    currentImageIndex = index;
                    resizeCanvasToAspect();
                    updateCurrentShapes();
                    updateImageThumbnails();
                    if (isGridView) {
                        toggleGridView();
                    }
                });
                container.appendChild(thumbnail);
            });
        }

        // Color mode selection
        document.getElementById('quizRGB').addEventListener('click', function () {
            colorMode = "RGB";
            document.getElementById('circleRGB').classList.add('selected');
            document.getElementById('circleCMYK').classList.remove('selected');
            updateShapeList();
            updateShapeDropdown();
        });

        document.getElementById('quizCMYK').addEventListener('click', function () {
            colorMode = "CMYK";
            document.getElementById('circleCMYK').classList.add('selected');
            document.getElementById('circleRGB').classList.remove('selected');
            updateShapeList();
            updateShapeDropdown();
        });

        // Set initial color mode
        document.getElementById('circleRGB').classList.add('selected');

        document.getElementById('toggleColorMode').addEventListener('click', function () {
            regressionStudioColorMode = regressionStudioColorMode === "RGB" ? "CMYK" : "RGB";
            document.getElementById('currentColorMode').textContent = regressionStudioColorMode;
            updateRegressionTable();
        });

        document.getElementById('chartSelector').addEventListener('change', function () {
            const selected = this.value;
            const components = ['red', 'green', 'blue', 'cyan', 'magenta', 'yellow', 'total'];

            components.forEach(component => {
                const chartDiv = document.getElementById(component + 'Chart').parentNode;
                if (selected === 'all' || selected === component) {
                    chartDiv.style.display = 'block';
                } else {
                    chartDiv.style.display = 'none';
                }
            });

            if (selected !== 'all' && regressionModels[selected]) {
                const model = regressionModels[selected];
                // ENHANCED: Proper negative slope formatting
                const interceptSign = model.b >= 0 ? '+' : '-';
                const interceptValue = Math.abs(model.b);
                document.getElementById('regressionOutput').innerHTML =
                    `<div style="font-size: 14px; text-align: center;">
                <strong>${selected.charAt(0).toUpperCase() + selected.slice(1)}:</strong> 
                y = ${model.m.toFixed(6)}x ${interceptSign} ${interceptValue.toFixed(6)}, R² = ${model.r2.toFixed(4)}
              </div>`;
            } else if (selected === 'all') {
                computeMultipleRegressions();
            }
        });

        // CSV download functionality
        document.getElementById('downloadCSV').addEventListener('click', function () {
            const allShapes = [];
            Object.keys(shapesByImage).forEach(imageKey => {
                allShapes.push(...shapesByImage[imageKey]);
            });

            if (allShapes.length === 0) {
                alert("No data to export. Please add shapes first.");
                return;
            }

            let csvContent = "Label,Red,Green,Blue,Cyan,Magenta,Yellow,Black,Known_Molarity,Image_Source,Image_Label\n";

            allShapes.forEach(shape => {
                const committedEntry = committedData.find(d => d.label === shape.label);
                const molarity = committedEntry ? committedEntry.y : "";
                const imageSource = shape.imageKey || "camera";
                const imageLabel = imageLabels[shape.imageKey] || "Unlabeled";
                const cmyk = rgbToCmyk(shape.color);

                const rgbFormatted = shape.color.map(v => formatColorValue(v));
                const cmykFormatted = cmyk;

                csvContent += `${shape.label},${rgbFormatted[0]},${rgbFormatted[1]},${rgbFormatted[2]},${cmykFormatted[0]},${cmykFormatted[1]},${cmykFormatted[2]},${cmykFormatted[3]},${molarity},${imageSource},"${imageLabel}"\n`;
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `color_analysis_data_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);

            alert("CSV exported successfully!");
        });

        // Sync slider and number inputs
        function syncInputs(rangeElem, numberElem) {
            rangeElem.addEventListener("input", function () {
                numberElem.value = this.value;
            });
            numberElem.addEventListener("input", function () {
                rangeElem.value = this.value;
            });
        }

        syncInputs(document.getElementById('param1Range'), document.getElementById('param1Val'));
        syncInputs(document.getElementById('param2Range'), document.getElementById('param2Val'));
        syncInputs(document.getElementById('minRadiusRange'), document.getElementById('minRadiusVal'));
        syncInputs(document.getElementById('maxRadiusRange'), document.getElementById('maxRadiusVal'));
        syncInputs(document.getElementById('restrictedAreaRange'), document.getElementById('restrictedAreaVal'));

        // ENHANCED: Update shapes list display
        function updateShapeList() {
            let list = document.getElementById('circleList');
            list.innerHTML = '';

            shapes.forEach(shape => {
                let li = document.createElement('li');
                let colorText = (colorMode === "CMYK") ?
                    `CMYK: ${rgbToCmyk(shape.color).join(', ')}` :
                    `RGB: ${shape.color.map(v => formatColorValue(v)).join(', ')}`;
                li.textContent = `${shape.label}: ${colorText} (${shape.type}${shape.auto ? " (auto)" : ""})`;
                list.appendChild(li);
            });
        }

        function updateShapeDropdown() {
            let select = document.getElementById('circleSelect');
            const currentSelection = select.value;
            select.innerHTML = '';

            shapes.forEach(shape => {
                let label = shape.label;
                let colorText = (colorMode === "CMYK") ?
                    `CMYK: ${rgbToCmyk(shape.color).join(', ')}` :
                    `RGB: ${shape.color.map(v => formatColorValue(v)).join(', ')}`;
                let option = document.createElement('option');
                option.value = label;
                option.textContent = `${label}: ${colorText} (${shape.type}${shape.auto ? " (auto)" : ""})`;
                select.appendChild(option);
            });

            if ([...select.options].some(option => option.value === currentSelection)) {
                select.value = currentSelection;
            }
        }

        document.getElementById('removeCircleButton').addEventListener('click', function () {
            let select = document.getElementById('circleSelect');
            let selectedLabel = select.value;
            let index = shapes.findIndex(s => s.label === selectedLabel);
            if (index !== -1) {
                recycleLabel(shapes[index].label);
                shapes.splice(index, 1);
                const imageKey = getCurrentImageKey();
                shapesByImage[imageKey] = shapes;
                updateShapeList();
                updateShapeDropdown();
            }
        });

        function updatePredictDropdown() {
            const predictSel = document.getElementById('predictShapeSelect');
            predictSel.innerHTML = '';

            Object.keys(shapesByImage).forEach(imageKey => {
                shapesByImage[imageKey].forEach(shape => {
                    const opt = document.createElement('option');
                    opt.value = shape.label;
                    opt.textContent = shape.label;
                    predictSel.appendChild(opt);
                });
            });
        }

        // ENHANCED: Update displays periodically
        setInterval(() => {
            updateShapeList();
            updateShapeDropdown();
        }, 1000);

        function updateRegressionTable() {
            const tbody = document.querySelector('#regressionTable tbody');
            tbody.innerHTML = '';

            const allShapes = [];
            Object.keys(shapesByImage).forEach(imageKey => {
                allShapes.push(...shapesByImage[imageKey]);
            });

            allShapes.forEach(shape => {
                const tr = document.createElement('tr');
                const speciesIcon = generateSpeciesIcon(shape);

                tr.innerHTML = `
                    <td>${shape.label}</td>
                    <td>RGB: [${shape.color.map(v => formatColorValue(v)).join(',')}]</td>
                    <td>CMYK: [${rgbToCmyk(shape.color).join(',')}]</td>
                    <td><input type="number" step="0.01" min="0" data-label="${shape.label}"></td>
                    <td><img src="${speciesIcon}" alt="${shape.label}" class="species-icon"></td>
                    <td><button class="btn btn--danger btn--small" data-label="${shape.label}">Remove</button></td>`;
                tbody.appendChild(tr);

                // Remove button handler
                tr.querySelector('button').addEventListener('click', e => {
                    const lbl = e.currentTarget.dataset.label;
                    
                    recycleLabel(lbl);
                    
                    committedData = committedData.filter(pt => pt.label !== lbl);
                    localStorage.setItem('committedData', JSON.stringify(committedData));

                    Object.keys(shapesByImage).forEach(imageKey => {
                        shapesByImage[imageKey] = shapesByImage[imageKey].filter(s => s.label !== lbl);
                    });

                    updateCurrentShapes();
                    e.currentTarget.closest('tr').remove();
                    updatePredictDropdown();
                });

                const input = tr.querySelector('input');
                input.addEventListener('input', function () {
                    const y = parseFloat(this.value);
                    const label = this.dataset.label;

                    committedData = committedData.filter(pt => pt.label !== label);

                    if (!isNaN(y)) {
                        committedData.push({ label, y });
                    }

                    localStorage.setItem('committedData', JSON.stringify(committedData));
                });
            });

            updatePredictDropdown();
        }

        function getPointsForRegression() {
            const pts = [];
            document.querySelectorAll('#regressionTable tbody tr').forEach(tr => {
                const input = tr.querySelector('input');
                const label = input.dataset.label;
                const y = parseFloat(input.value);
                if (isNaN(y)) return;

                let shape = null;
                Object.keys(shapesByImage).forEach(imageKey => {
                    const foundShape = shapesByImage[imageKey].find(s => s.label === label);
                    if (foundShape) shape = foundShape;
                });

                if (!shape) return;

                const raw = shape.color.map(v => formatColorValue(v));
                const cmyk = rgbToCmyk(raw);
                const total = Math.round(Math.sqrt(raw[0] ** 2 + raw[1] ** 2 + raw[2] ** 2));

                pts.push({
                    label,
                    y: y,
                    red: raw[0],
                    green: raw[1],
                    blue: raw[2],
                    cyan: cmyk[0],
                    magenta: cmyk[1],
                    yellow: cmyk[2],
                    total
                });
            });
            return pts;
        }

        document.getElementById('predictBtn').addEventListener('click', () => {
            if (Object.keys(regressionModels).length === 0) {
                alert('Run regression first.');
                return;
            }
            const label = document.getElementById('predictShapeSelect').value;

            let shape = null;
            Object.keys(shapesByImage).forEach(imageKey => {
                const foundShape = shapesByImage[imageKey].find(s => s.label === label);
                if (foundShape) shape = foundShape;
            });

            if (!shape) return;

            const raw = shape.color.map(v => formatColorValue(v));
            const cmyk = rgbToCmyk(raw);
            const total = Math.round(Math.sqrt(raw[0] ** 2 + raw[1] ** 2 + raw[2] ** 2));

            let predictions = [];
            if (regressionModels.red) {
                predictions.push(`Red: ${(regressionModels.red.m * raw[0] + regressionModels.red.b).toFixed(4)}`);
            }
            if (regressionModels.green) {
                predictions.push(`Green: ${(regressionModels.green.m * raw[1] + regressionModels.green.b).toFixed(4)}`);
            }
            if (regressionModels.blue) {
                predictions.push(`Blue: ${(regressionModels.blue.m * raw[2] + regressionModels.blue.b).toFixed(4)}`);
            }
            if (regressionModels.cyan) {
                predictions.push(`Cyan: ${(regressionModels.cyan.m * cmyk[0] + regressionModels.cyan.b).toFixed(4)}`);
            }
            if (regressionModels.magenta) {
                predictions.push(`Magenta: ${(regressionModels.magenta.m * cmyk[1] + regressionModels.magenta.b).toFixed(4)}`);
            }
            if (regressionModels.yellow) {
                predictions.push(`Yellow: ${(regressionModels.yellow.m * cmyk[2] + regressionModels.yellow.b).toFixed(4)}`);
            }
            if (regressionModels.total) {
                predictions.push(`Total: ${(regressionModels.total.m * total + regressionModels.total.b).toFixed(4)}`);
            }

            document.getElementById('predictOutput').innerHTML = `
                <strong>Predicted Molarity for ${label}:</strong><br>
                ${predictions.join('<br>')}`;
        });

        document.getElementById('runRegressionBtn').addEventListener('click', computeMultipleRegressions);

        function computeMultipleRegressions() {
            const pts = getPointsForRegression();

            if (pts.length < 2) {
                alert('Please enter at least two known molarity values.');
                return;
            }

            const components = ['red', 'green', 'blue', 'cyan', 'magenta', 'yellow', 'total'];
            regressionModels = {};
            let outputHtml = `<div style="font-size: 14px; text-align: center;">`;

            components.forEach(component => {
                const model = calculateEnhancedRegression(pts, component);
                if (model) {
                    regressionModels[component] = model;
                    // ENHANCED: Proper negative slope formatting
                    const interceptSign = model.b >= 0 ? '+' : '-';
                    const interceptValue = Math.abs(model.b);
                    outputHtml += `<strong>${component.charAt(0).toUpperCase() + component.slice(1)}:</strong> y = ${model.m.toFixed(6)}x ${interceptSign} ${interceptValue.toFixed(6)}, R² = ${model.r2.toFixed(4)}<br>`;
                    drawComponentChart(component, pts, model);
                }
            });

            outputHtml += '</div>';
            document.getElementById('regressionOutput').innerHTML = outputHtml;
        }

        // Model export/import functions
        document.getElementById('exportModelBtn').addEventListener('click', () => {
            const allShapes = [];
            Object.keys(shapesByImage).forEach(imageKey => {
                allShapes.push(...shapesByImage[imageKey]);
            });

            if (allShapes.length === 0) {
                alert("No shapes to export. Please add shapes first.");
                return;
            }

            const exportData = {
                version: "6.0_all_issues_fixed",
                timestamp: new Date().toISOString(),
                colorMode: colorMode,
                regressionStudioColorMode: regressionStudioColorMode,
                decimalPrecision: decimalPrecision,
                committedData: committedData,
                regressionModels: regressionModels,
                shapesByImage: shapesByImage,
                imageLabels: imageLabels,
                shapeIdCounter: shapeIdCounter,
                availableLabels: availableLabels,
                zoomLevel: zoomLevel,
                axesSwapped: axesSwapped
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `color_analysis_enhanced_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);

            alert("Enhanced model exported successfully!");
        });

        document.getElementById('importModelBtn').addEventListener('click', () => {
            document.getElementById('importModelInput').click();
        });

        document.getElementById('importModelInput').addEventListener('change', e => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const importData = JSON.parse(reader.result);

                    if (!importData.version || !importData.shapesByImage) {
                        throw new Error("Invalid or outdated model file format");
                    }

                    shapesByImage = importData.shapesByImage || {};
                    committedData = importData.committedData || [];
                    regressionModels = importData.regressionModels || {};
                    imageLabels = importData.imageLabels || {};
                    shapeIdCounter = importData.shapeIdCounter || 0;
                    availableLabels = importData.availableLabels || [];
                    colorMode = importData.colorMode || "RGB";
                    regressionStudioColorMode = importData.regressionStudioColorMode || "RGB";
                    decimalPrecision = importData.decimalPrecision || 3;
                    zoomLevel = importData.zoomLevel || 1.0;
                    axesSwapped = importData.axesSwapped || false;

                    document.getElementById('precisionSelector').value = decimalPrecision.toString();
                    document.getElementById('axisSwapSelector').value = axesSwapped ? 'swapped' : 'normal';
                    updateZoom();

                    updateCurrentShapes();
                    updateRegressionTable();
                    updateImageThumbnails();

                    if (colorMode === "CMYK") {
                        document.getElementById('circleCMYK').classList.add('selected');
                        document.getElementById('circleRGB').classList.remove('selected');
                    } else {
                        document.getElementById('circleRGB').classList.add('selected');
                        document.getElementById('circleCMYK').classList.remove('selected');
                    }

                    document.getElementById('currentColorMode').textContent = regressionStudioColorMode;
                    localStorage.setItem('committedData', JSON.stringify(committedData));
                    localStorage.setItem('imageLabels', JSON.stringify(imageLabels));

                    alert(`Enhanced model imported successfully! Loaded ${Object.keys(shapesByImage).length} image(s) with shapes.`);

                } catch (err) {
                    alert('Error importing model: ' + err.message);
                }
            };
            reader.readAsText(file);
        });

        // Tab switching
        const detectTab = document.getElementById('detectTab');
        const regressionTab = document.getElementById('regressionTab');
        const tabDetectBtn = document.getElementById('tabDetectBtn');
        const tabRegressionBtn = document.getElementById('tabRegressionBtn');

        document.getElementById('tabDetectBtn').addEventListener('click', () => showTab('detect'));
        document.getElementById('tabRegressionBtn').addEventListener('click', () => showTab('regression'));

        function showTab(tab) {
            if (tab === 'detect') {
                detectTab.style.display = 'block';
                regressionTab.style.display = 'none';
                tabDetectBtn.classList.add('selected');
                tabRegressionBtn.classList.remove('selected');
            } else {
                detectTab.style.display = 'none';
                regressionTab.style.display = 'block';
                tabDetectBtn.classList.remove('selected');
                tabRegressionBtn.classList.add('selected');
                updateRegressionTable();
                updateImageThumbnails();
                autoRestoreData();
            }
        }

        function autoRestoreData() {
            committedData.forEach(({ label, y }) => {
                const input = document.querySelector(`#regressionTable input[data-label="${label}"]`);
                if (input) input.value = y;
            });
        }

        // Initialize OpenCV when ready
        if (typeof cv !== 'undefined') {
            onOpenCvReady();
        }

        // Initialize the application
        updateCurrentShapes();
        initializeDraggableUI();

        if (committedData.length > 0) {
            console.log('Loaded committed data:', committedData);
        }

        if (Object.keys(imageLabels).length > 0) {
            console.log('Loaded image labels:', imageLabels);
        }
    </script>

    <!-- Load OpenCV.js -->
    <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
</body>

</html>
